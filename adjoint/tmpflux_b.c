/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
*/
#include <adBuffer.h>
#include "../include/structures.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*
  Differentiation of tmpflux in reverse (adjoint) mode:
   gradient     of useful results: *q_l *q_r *rhs_m1 *rhs
   with respect to varying inputs: *q_l *q_r *rhs_m1 *rhs
   RW status of diff variables: *q_l:incr *q_r:incr *rhs_m1:in-out
                *rhs:in-out
   Plus diff mem management of: q_l:in q_r:in rhs_m1:in rhs:in
*/
void tmpflux_b(double *q_l, double *q_lb, double *q_r, double *q_rb, double *
        rhs_m1, double *rhs_m1b, double *rhs, double *rhsb, Dim *dim, double S
        [2], int mini, int maxi) {
    double f[4];
    double fb[4];
    // void tmpflux(double* q_l, double* q_r, double *f, Dim *dim, double S[2]){
    double rho_l = q_l[0];
    double rho_lb;
    double rho_r = q_r[0];
    double rho_rb;
    double inv_rho_l = 1.0/rho_l;
    double inv_rho_lb;
    double inv_rho_r = 1.0/rho_r;
    double inv_rho_rb;
    double u_l = q_l[1]*inv_rho_l;
    double u_lb;
    double u_r = q_r[1]*inv_rho_r;
    double u_rb;
    double v_l = q_l[2]*inv_rho_l;
    double v_lb;
    double v_r = q_r[2]*inv_rho_r;
    double v_rb;
    double e_l = q_l[3];
    double e_lb;
    double e_r = q_r[3];
    double e_rb;
    double p_l = (1.4-1.0)*(e_l-0.5*rho_l*(u_l*u_l+v_l*v_l));
    double p_lb;
    double p_r = (1.4-1.0)*(e_r-0.5*rho_r*(u_r*u_r+v_r*v_r));
    double p_rb;
    // face size and normals
    double mag;
    int ii1;
    double tempb;
    double tempb0;
    double tempb1;
    double tempb2;
    double tempb3;
    double tempb4;
    double tempb5;
    double tempb6;
    double tempb7;
    double tempb8;
    double tempb9;
    double tempb10;
    mag = sqrt(S[0]*S[0] + S[1]*S[1]);
    double imag = 1.0/mag;
    double r1 = S[0]*imag;
    double r2 = S[1]*imag;
    double V_l = u_l*r1 + v_l*r2;
    double V_lb;
    double V_r = u_r*r1 + v_r*r2;
    double V_rb;
    double dF0;
    double dF0b;
    double dF1;
    double dF1b;
    double dF2;
    double dF2b;
    double dF3;
    double dF3b;
    double c_l;
    double c_lb;
    c_l = sqrt(1.4*p_l*inv_rho_l);
    double c_r;
    double c_rb;
    c_r = sqrt(1.4*p_r*inv_rho_r);
    double eig_l, eig_r;
    double eig_lb, eig_rb;
    eig_l = sqrt(V_l*V_l) + c_l;
    eig_r = sqrt(V_r*V_r) + c_r;
    double rad = 0.5*(eig_l+eig_r);
    double radb;
    double half_face = 0.5*mag;
    // if(j_or_k > dim->nghost){
    // }
    // if(is_j==1 && j_or_k < dim->nghost + dim->jmax){
    //   rhs[0]    = rhs[0] - f[0];
    //   rhs[1]    = rhs[1] - f[1];
    //   rhs[2]    = rhs[2] - f[2];
    //   rhs[3]    = rhs[3] - f[3];
    // }
    // if(is_j==0 && j_or_k < dim->nghost + dim->kmax){
    //   rhs[0]    = rhs[0] - f[0];
    //   rhs[1]    = rhs[1] - f[1];
    //   rhs[2]    = rhs[2] - f[2];
    //   rhs[3]    = rhs[3] - f[3];
    // }
    for (ii1 = 0; ii1 < 4; ++ii1)
        fb[ii1] = 0.0;
    fb[3] = fb[3] - (1-maxi)*rhsb[3];
    fb[2] = fb[2] - (1-maxi)*rhsb[2];
    fb[1] = fb[1] - (1-maxi)*rhsb[1];
    fb[0] = fb[0] - (1-maxi)*rhsb[0];
    fb[3] = fb[3] + (1-mini)*rhs_m1b[3];
    fb[2] = fb[2] + (1-mini)*rhs_m1b[2];
    fb[1] = fb[1] + (1-mini)*rhs_m1b[1];
    fb[0] = fb[0] + (1-mini)*rhs_m1b[0];
    tempb = half_face*fb[3];
    dF3b = -tempb;
    fb[3] = 0.0;
    tempb0 = half_face*fb[2];
    dF2b = -tempb0;
    fb[2] = 0.0;
    tempb2 = half_face*fb[1];
    dF1b = -tempb2;
    fb[1] = 0.0;
    tempb3 = half_face*fb[0];
    dF0b = -tempb3;
    tempb7 = 0.25*rad*dF3b;
    radb = 0.25*(q_r[2]-q_l[2])*dF2b + 0.25*(q_r[0]-q_l[0])*dF0b + 0.25*(q_r[1
        ]-q_l[1])*dF1b + 0.25*(q_r[3]-q_l[3])*dF3b;
    q_rb[3] = q_rb[3] + tempb7;
    q_lb[3] = q_lb[3] - tempb7;
    tempb8 = 0.25*rad*dF2b;
    q_rb[2] = q_rb[2] + tempb8;
    q_lb[2] = q_lb[2] - tempb8;
    tempb9 = 0.25*rad*dF1b;
    q_rb[1] = q_rb[1] + tempb9;
    q_lb[1] = q_lb[1] - tempb9;
    tempb10 = 0.25*rad*dF0b;
    q_rb[0] = q_rb[0] + tempb10;
    q_lb[0] = q_lb[0] - tempb10;
    eig_lb = 0.5*radb;
    if (V_l*V_l == 0.0)
        V_lb = rho_l*v_l*tempb0 + rho_l*tempb3 + rho_l*u_l*tempb2 + (e_l+p_l)*
            tempb;
    else
        V_lb = rho_l*v_l*tempb0 + rho_l*tempb3 + 2*V_l*eig_lb/(2.0*sqrt(V_l*
            V_l)) + rho_l*u_l*tempb2 + (e_l+p_l)*tempb;
    eig_rb = 0.5*radb;
    if (V_r*V_r == 0.0)
        V_rb = rho_r*v_r*tempb0 + rho_r*tempb3 + rho_r*u_r*tempb2 + (e_r+p_r)*
            tempb;
    else
        V_rb = rho_r*v_r*tempb0 + rho_r*tempb3 + 2*V_r*eig_rb/(2.0*sqrt(V_r*
            V_r)) + rho_r*u_r*tempb2 + (e_r+p_r)*tempb;
    c_rb = eig_rb;
    c_lb = eig_lb;
    if (1.4*(p_r*inv_rho_r) == 0.0)
        tempb4 = 0.0;
    else
        tempb4 = 1.4*c_rb/(2.0*sqrt(1.4*(p_r*inv_rho_r)));
    p_rb = r2*tempb0 + inv_rho_r*tempb4 + r1*tempb2 + V_r*tempb;
    e_rb = 0.4*p_rb + V_r*tempb;
    if (1.4*(p_l*inv_rho_l) == 0.0)
        tempb1 = 0.0;
    else
        tempb1 = 1.4*c_lb/(2.0*sqrt(1.4*(p_l*inv_rho_l)));
    p_lb = r2*tempb0 + inv_rho_l*tempb1 + r1*tempb2 + V_l*tempb;
    e_lb = 0.4*p_lb + V_l*tempb;
    tempb6 = -(0.4*0.5*p_rb);
    v_rb = r2*V_rb + rho_r*2*v_r*tempb6 + V_r*rho_r*tempb0;
    u_rb = r1*V_rb + rho_r*2*u_r*tempb6 + V_r*rho_r*tempb2;
    inv_rho_rb = q_r[2]*v_rb + q_r[1]*u_rb + p_r*tempb4;
    rho_rb = V_r*u_r*tempb2 + (u_r*u_r+v_r*v_r)*tempb6 - inv_rho_rb/(rho_r*
        rho_r) + V_r*tempb3 + V_r*v_r*tempb0;
    tempb5 = -(0.4*0.5*p_lb);
    v_lb = r2*V_lb + rho_l*2*v_l*tempb5 + V_l*rho_l*tempb0;
    u_lb = r1*V_lb + rho_l*2*u_l*tempb5 + V_l*rho_l*tempb2;
    inv_rho_lb = q_l[2]*v_lb + q_l[1]*u_lb + p_l*tempb1;
    rho_lb = V_l*u_l*tempb2 + (u_l*u_l+v_l*v_l)*tempb5 - inv_rho_lb/(rho_l*
        rho_l) + V_l*tempb3 + V_l*v_l*tempb0;
    q_rb[3] = q_rb[3] + e_rb;
    q_lb[3] = q_lb[3] + e_lb;
    q_rb[2] = q_rb[2] + inv_rho_r*v_rb;
    q_lb[2] = q_lb[2] + inv_rho_l*v_lb;
    q_rb[1] = q_rb[1] + inv_rho_r*u_rb;
    q_lb[1] = q_lb[1] + inv_rho_l*u_lb;
    q_rb[0] = q_rb[0] + rho_rb;
    q_lb[0] = q_lb[0] + rho_lb;
}
