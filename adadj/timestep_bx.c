/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.15 (master) - 15 Apr 2020 13:10
*/
#include <adBuffer.h>
#include "structures.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/*
  Differentiation of ad_timestep in reverse (adjoint) mode:
   gradient     of useful results: q[0:4-1] *dt xy1[0:2-1] xy2[0:2-1]
                xy3[0:2-1]
   with respect to varying inputs: q[0:4-1] *dt xy1[0:2-1] xy2[0:2-1]
                xy3[0:2-1]
   RW status of diff variables: q[0:4-1]:incr *dt:in-out xy1[0:2-1]:incr
                xy2[0:2-1]:incr xy3[0:2-1]:incr
   Plus diff mem management of: q:in dt:in xy1:in xy2:in xy3:in
*/
void ad_timestep_bx(double q[4], double qb[4], double xy1[2], double xy1b[2], 
        double xy2[2], double xy2b[2], double xy3[2], double xy3b[2], double 
        cfl, double *dt, double *dtb) {
    // xy1  is j  , k   pt
    // xy2  is j+1, k   pt
    // xy3  is j  , k+1 pt
    double Sk[2], Sj[2];
    double Skb[2], Sjb[2];
    double fabs0;
    double fabs0b;
    double fabs1;
    double fabs1b;
    double tempb;
    int ii1;
    int branch;
    Sk[0] = -xy2[1] + xy1[1];
    Sk[1] = xy2[0] - xy1[0];
    Sj[0] = xy3[1] - xy1[1];
    Sj[1] = -xy3[0] + xy1[0];
    //
    // Constant-CFL timestep
    //
    double u, v, p, c2, irho;
    double ub, vb, pb, c2b, irhob;
    double uu, vv;
    double uub, vvb;
    double xs2, ys2, xsc, ysc, eigmax;
    double xs2b, ys2b, xscb, yscb, eigmaxb;
    if (cfl > 0.5)
        cfl = 0.5;
    irho = 1.0/q[0];
    u = q[1]*irho;
    v = q[2]*irho;
    p = (1.4-1.0)*(q[3]-0.5*q[0]*(u*u+v*v));
    c2 = 1.4*p*irho;
    // contravariant velocities in coordinate directions
    uu = u*Sj[0] + v*Sj[1];
    vv = u*Sk[0] + v*Sk[1];
    // face sizes squared
    xs2 = Sj[0]*Sj[0] + Sj[1]*Sj[1];
    ys2 = Sk[0]*Sk[0] + Sk[1]*Sk[1];
    xsc = sqrt(c2*xs2);
    ysc = sqrt(c2*ys2);
    if (uu >= 0.0) {
        fabs0 = uu;
        pushControl1b(1);
    } else {
        fabs0 = -uu;
        pushControl1b(0);
    }
    if (vv >= 0.0) {
        fabs1 = vv;
        pushControl1b(0);
    } else {
        fabs1 = -vv;
        pushControl1b(1);
    }
    eigmax = fabs0 + xsc + fabs1 + ysc;
    //eigmax = fmax( abs(uu) + xsc, abs(vv) + ysc );
    // dt[0] = cfl * V[0] / eigmax;
    // actually dt over volume since later we would divide dt by volume anyway
    // dt[0] = eigmax;
    eigmaxb = -(cfl*dtb[0]/(eigmax*eigmax));
    dtb[0] = 0.0;
    fabs0b = eigmaxb;
    xscb = eigmaxb;
    fabs1b = eigmaxb;
    yscb = eigmaxb;
    popControl1b(&branch);
    if (branch == 0)
        vvb = fabs1b;
    else
        vvb = -fabs1b;
    popControl1b(&branch);
    if (branch == 0)
        uub = -fabs0b;
    else
        uub = fabs0b;
    tempb = (c2*ys2 == 0.0 ? 0.0 : yscb/(2.0*sqrt(c2*ys2)));
    c2b = ys2*tempb;
    ys2b = c2*tempb;
    tempb = (c2*xs2 == 0.0 ? 0.0 : xscb/(2.0*sqrt(c2*xs2)));
    c2b = c2b + xs2*tempb;
    xs2b = c2*tempb;
    for (ii1 = 0; ii1 < 2; ++ii1)
        Skb[ii1] = 0.0;
    Skb[1] = Skb[1] + 2*Sk[1]*ys2b + v*vvb;
    Skb[0] = Skb[0] + 2*Sk[0]*ys2b + u*vvb;
    for (ii1 = 0; ii1 < 2; ++ii1)
        Sjb[ii1] = 0.0;
    Sjb[1] = Sjb[1] + 2*Sj[1]*xs2b + v*uub;
    Sjb[0] = Sjb[0] + 2*Sj[0]*xs2b + u*uub;
    pb = irho*1.4*c2b;
    qb[3] = qb[3] + 0.4*pb;
    tempb = -(0.5*0.4*pb);
    ub = Sk[0]*vvb + Sj[0]*uub + 2*u*q[0]*tempb;
    vb = Sk[1]*vvb + Sj[1]*uub + 2*v*q[0]*tempb;
    irhob = p*1.4*c2b + q[2]*vb + q[1]*ub;
    qb[0] = qb[0] + (u*u+v*v)*tempb;
    qb[2] = qb[2] + irho*vb;
    qb[1] = qb[1] + irho*ub;
    qb[0] = qb[0] - irhob/(q[0]*q[0]);
    xy1b[0] = xy1b[0] + Sjb[1];
    xy3b[0] = xy3b[0] - Sjb[1];
    Sjb[1] = 0.0;
    xy3b[1] = xy3b[1] + Sjb[0];
    xy1b[1] = xy1b[1] - Sjb[0];
    xy2b[0] = xy2b[0] + Skb[1];
    xy1b[0] = xy1b[0] - Skb[1];
    Skb[1] = 0.0;
    xy1b[1] = xy1b[1] + Skb[0];
    xy2b[1] = xy2b[1] - Skb[0];
}
