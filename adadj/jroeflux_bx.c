/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
*/
#include <adBuffer.h>
#include "../include/structures.h"

/*
  Differentiation of jroeflux in reverse (adjoint) mode:
   gradient     of useful results: xy1[0:2-1] xy2[0:2-1] *q_l
                *q_r *rhs_m1 *rhs
   with respect to varying inputs: xy1[0:2-1] xy2[0:2-1] *q_l
                *q_r *rhs_m1 *rhs
   RW status of diff variables: xy1[0:2-1]:incr xy2[0:2-1]:incr
                *q_l:incr *q_r:incr *rhs_m1:in-out *rhs:in-out
   Plus diff mem management of: xy1:in xy2:in q_l:in q_r:in rhs_m1:in
                rhs:in
*/
void jroeflux_bx(double *q_l, double *q_lb, double *q_r, double *q_rb, double 
        *rhs_m1, double *rhs_m1b, double *rhs, double *rhsb, Dim *dim, double 
        xy1[2], double xy1b[2], double xy2[2], double xy2b[2], int j) {
    double f[4];
    double fb[4];
    double S[2];
    double Sb[2];
    double temp;
    double temp0;
    double temp1;
    double temp2;
    int ii1;
    double tempb;
    double tempb0;
    double tempb1;
    double tempb2;
    double tempb3;
    double tempb4;
    double tempb5;
    double tempb6;
    double tempb7;
    double tempb8;
    double tempb9;
    double tempb10;
    double tempb11;
    double tempb12;
    double tempb13;
    double tempb14;
    double tempb15;
    double temp3;
    double temp4;
    double tempb16;
    double tempb17;
    double tempb18;
    double tempb19;
    double tempb20;
    double tempb21;
    double tempb22;
    double tempb23;
    double tempb24;
    double tempb25;
    double tempb26;
    double tempb27;
    double tempb28;
    double tempb29;
    double tempb30;
    double tempb31;
    double tempb32;
    double tempb33;
    double tempb34;
    double tempb35;
    double tempb36;
    double tempb37;
    double tempb38;
    double tempb39;
    double tempb40;
    int branch;
    // for k face:
    // S[0] = - xy2[1] + xy1[1];
    // S[1] =   xy2[0] - xy1[0];
    S[0] = xy2[1] - xy1[1];
    S[1] = -xy2[0] + xy1[0];
    //
    // Computing Roe Averages
    //
    double tmp;
    double tmpb;
    double rho_l = q_l[0];
    double rho_lb;
    double rho_r = q_r[0];
    double rho_rb;
    double rho_av;
    double rho_avb;
    rho_av = sqrt(rho_l*rho_r);
    double inv_rho_l = 1.0/rho_l;
    double inv_rho_lb;
    double inv_rho_r = 1.0/rho_r;
    double inv_rho_rb;
    double roe_wt_1 = sqrt(rho_l)/(sqrt(rho_l)+sqrt(rho_r));
    double roe_wt_1b;
    double roe_wt_2 = 1 - roe_wt_1;
    double roe_wt_2b;
    double u_l = q_l[1]*inv_rho_l;
    double u_lb;
    double u_r = q_r[1]*inv_rho_r;
    double u_rb;
    double u_av = roe_wt_1*u_l + roe_wt_2*u_r;
    double u_avb;
    double v_l = q_l[2]*inv_rho_l;
    double v_lb;
    double v_r = q_r[2]*inv_rho_r;
    double v_rb;
    double v_av = roe_wt_1*v_l + roe_wt_2*v_r;
    double v_avb;
    double e_l = q_l[3];
    double e_lb;
    double e_r = q_r[3];
    double e_rb;
    double p_l = (1.4-1.0)*(e_l-0.5*rho_l*(u_l*u_l+v_l*v_l));
    double p_lb;
    double p_r = (1.4-1.0)*(e_r-0.5*rho_r*(u_r*u_r+v_r*v_r));
    double p_rb;
    double q_sqr_av = u_av*u_av + v_av*v_av;
    double q_sqr_avb;
    double h_l = (e_l+p_l)*inv_rho_l;
    double h_lb;
    double h_r = (e_r+p_r)*inv_rho_r;
    double h_rb;
    double h_av = roe_wt_1*h_l + roe_wt_2*h_r;
    double h_avb;
    double c_l;
    double c_lb;
    c_l = sqrt(1.4*p_l*inv_rho_l);
    double c_r;
    double c_rb;
    c_r = sqrt(1.4*p_r*inv_rho_r);
    double c_av;
    double c_avb;
    c_av = sqrt((1.4-1.0)*(h_av-0.5*q_sqr_av));
    // face size and normals
    double mag;
    double magb;
    mag = sqrt(S[0]*S[0] + S[1]*S[1]);
    double imag = 1.0/mag;
    double imagb;
    double r1 = S[0]*imag;
    double r1b;
    double r2 = S[1]*imag;
    double r2b;
    // need vn grid here for lambdas below
    double V_l = u_l*r1 + v_l*r2;
    double V_lb;
    double V_r = u_r*r1 + v_r*r2;
    double V_rb;
    double V = u_av*r1 + v_av*r2;
    double Vb;
    //
    // Computing Local Eigenvalues
    //
    double eig_a1 = V;
    double eig_a1b;
    double eig_a2 = V + c_av;
    double eig_a2b;
    double eig_a3 = V - c_av;
    double eig_a3b;
    double eig_l1 = V_l;
    double eig_l1b;
    double eig_l2 = V_l + c_l;
    double eig_l2b;
    double eig_l3 = V_l - c_l;
    double eig_l3b;
    double eig_r1 = V_r;
    double eig_r1b;
    double eig_r2 = V_r + c_r;
    double eig_r2b;
    double eig_r3 = V_r - c_r;
    double eig_r3b;
    // Dylan: this looks like Harten's Entropy Correction but I'm not sure
    double lambda_tilda, lambda_tilda_s;
    if (eig_a1 >= 0.) {
        pushcontrol1b(0);
        eig_a1 = eig_a1;
    } else {
        eig_a1 = -eig_a1;
        pushcontrol1b(1);
    }
    if (eig_a2 >= 0.) {
        pushcontrol1b(0);
        eig_a2 = eig_a2;
    } else {
        eig_a2 = -eig_a2;
        pushcontrol1b(1);
    }
    if (eig_a3 >= 0.) {
        pushcontrol1b(0);
        eig_a3 = eig_a3;
    } else {
        eig_a3 = -eig_a3;
        pushcontrol1b(1);
    }
    if (4.0*(eig_r1-eig_l1) + 1e-6 < 0.0)
        lambda_tilda = 0.0;
    else
        lambda_tilda = 4.0*(eig_r1-eig_l1) + 1e-6;
    if (eig_a1 < 0.5*lambda_tilda) {
        pushreal8(eig_a1);
        eig_a1 = eig_a1*eig_a1/(4.0*(eig_r1-eig_l1)+1e-6) + 0.25*(4.0*(eig_r1-
            eig_l1)+1e-6);
        pushcontrol1b(1);
    } else
        pushcontrol1b(0);
    if (4.0*(eig_r2-eig_l2) + 1e-6 < 0.0)
        lambda_tilda = 0.0;
    else
        lambda_tilda = 4.0*(eig_r2-eig_l2) + 1e-6;
    if (eig_a2 < 0.5*lambda_tilda) {
        pushreal8(eig_a2);
        eig_a2 = eig_a2*eig_a2/(4.0*(eig_r2-eig_l2)+1e-6) + 0.25*(4.0*(eig_r2-
            eig_l2)+1e-6);
        pushcontrol1b(1);
    } else
        pushcontrol1b(0);
    if (4.0*(eig_r3-eig_l3) + 1e-6 < 0.0)
        lambda_tilda = 0.0;
    else
        lambda_tilda = 4.0*(eig_r3-eig_l3) + 1e-6;
    if (eig_a3 < 0.5*lambda_tilda) {
        pushreal8(eig_a3);
        eig_a3 = eig_a3*eig_a3/(4.0*(eig_r3-eig_l3)+1e-6) + 0.25*(4.0*(eig_r3-
            eig_l3)+1e-6);
        pushcontrol1b(0);
    } else
        pushcontrol1b(1);
    double drho = rho_r - rho_l;
    double drhob;
    double dp = p_r - p_l;
    double dpb;
    double du = u_r - u_l;
    double dub;
    double dv = v_r - v_l;
    double dvb;
    double dV = V_r - V_l;
    double dVb;
    // quantity in parentheses blazek eq 4.90
    double drho_dp = drho - dp/(c_av*c_av);
    double drho_dpb;
    // quantity in parentheses blazek eq 4.89, 4.91
    tmp = 1.0/(2.0*c_av*c_av);
    double dp_p_rho_c = (dp+rho_av*c_av*dV)*tmp;
    double dp_p_rho_cb;
    double dp_m_rho_c = (dp-rho_av*c_av*dV)*tmp;
    double dp_m_rho_cb;
    double dF0, dF1, dF2, dF3;
    double dF0b, dF1b, dF2b, dF3b;
    // delta F, blazek eqn. 4.89-4.91
    // eqn. 4.90
    dF0 = eig_a1*drho_dp;
    dF1 = eig_a1*(drho_dp*u_av+rho_av*(du-dV*r1));
    dF2 = eig_a1*(drho_dp*v_av+rho_av*(dv-dV*r2));
    dF3 = eig_a1*(drho_dp*q_sqr_av*0.5+rho_av*(u_av*du+v_av*dv-V*dV));
    // eqn. 4.91
    dF0 = dF0 + eig_a2*dp_p_rho_c;
    dF1 = dF1 + eig_a2*dp_p_rho_c*(u_av+c_av*r1);
    dF2 = dF2 + eig_a2*dp_p_rho_c*(v_av+c_av*r2);
    dF3 = dF3 + eig_a2*dp_p_rho_c*(h_av+c_av*V);
    // eqn 4.89
    dF0 = dF0 + eig_a3*dp_m_rho_c;
    dF1 = dF1 + eig_a3*dp_m_rho_c*(u_av-c_av*r1);
    dF2 = dF2 + eig_a3*dp_m_rho_c*(v_av-c_av*r2);
    dF3 = dF3 + eig_a3*dp_m_rho_c*(h_av-c_av*V);
    double half_face = 0.5*mag;
    double half_faceb;
    if (j > dim->nghost)
        pushcontrol1b(0);
    else
        pushcontrol1b(1);
    if (j < dim->nghost + dim->jmax) {
        for (ii1 = 0; ii1 < 4; ++ii1)
            fb[ii1] = 0.0;
        fb[3] = fb[3] + rhsb[3];
        fb[2] = fb[2] + rhsb[2];
        fb[1] = fb[1] + rhsb[1];
        fb[0] = fb[0] + rhsb[0];
    } else
        for (ii1 = 0; ii1 < 4; ++ii1)
            fb[ii1] = 0.0;
    popcontrol1b(&branch);
    if (branch == 0) {
        fb[3] = fb[3] - rhs_m1b[3];
        fb[2] = fb[2] - rhs_m1b[2];
        fb[1] = fb[1] - rhs_m1b[1];
        fb[0] = fb[0] - rhs_m1b[0];
    }
    tempb16 = half_face*fb[3];
    half_faceb = ((e_l+p_l)*V_l+(e_r+p_r)*V_r-dF3)*fb[3];
    e_lb = V_l*tempb16;
    e_rb = V_r*tempb16;
    dF3b = -tempb16;
    fb[3] = 0.0;
    tempb17 = half_face*fb[2];
    half_faceb = half_faceb + (rho_l*v_l*V_l+p_l*r2+rho_r*v_r*V_r+p_r*r2-dF2)*
        fb[2];
    dF2b = -tempb17;
    fb[2] = 0.0;
    tempb18 = half_face*fb[1];
    half_faceb = half_faceb + (rho_l*u_l*V_l+p_l*r1+rho_r*u_r*V_r+p_r*r1-dF1)*
        fb[1];
    dF1b = -tempb18;
    fb[1] = 0.0;
    tempb19 = half_face*fb[0];
    half_faceb = half_faceb + (rho_l*V_l+rho_r*V_r-dF0)*fb[0];
    dF0b = -tempb19;
    magb = 0.5*half_faceb;
    tempb26 = (h_av-c_av*V)*dF3b;
    tempb27 = eig_a3*dp_m_rho_c*dF3b;
    tempb28 = (v_av-c_av*r2)*dF2b;
    tempb20 = eig_a3*dp_m_rho_c*dF2b;
    tempb29 = (u_av-c_av*r1)*dF1b;
    eig_a3b = dp_m_rho_c*tempb28 + dp_m_rho_c*dF0b + dp_m_rho_c*tempb29 + 
        dp_m_rho_c*tempb26;
    dp_m_rho_cb = eig_a3*tempb28 + eig_a3*dF0b + eig_a3*tempb29 + eig_a3*
        tempb26;
    tempb23 = eig_a3*dp_m_rho_c*dF1b;
    tempb37 = (h_av+c_av*V)*dF3b;
    tempb30 = eig_a2*dp_p_rho_c*dF3b;
    h_avb = tempb30 + tempb27;
    tempb38 = (v_av+c_av*r2)*dF2b;
    tempb22 = eig_a2*dp_p_rho_c*dF2b;
    tempb39 = (u_av+c_av*r1)*dF1b;
    eig_a2b = dp_p_rho_c*tempb38 + dp_p_rho_c*dF0b + dp_p_rho_c*tempb39 + 
        dp_p_rho_c*tempb37;
    dp_p_rho_cb = eig_a2*tempb38 + eig_a2*dF0b + eig_a2*tempb39 + eig_a2*
        tempb37;
    tempb25 = eig_a2*dp_p_rho_c*dF1b;
    temp4 = u_av*du + v_av*dv - V*dV;
    tempb40 = eig_a1*dF3b;
    tempb34 = rho_av*tempb40;
    Vb = c_av*tempb30 - dV*tempb34 - c_av*tempb27;
    eig_a1b = (drho_dp*v_av+rho_av*(dv-dV*r2))*dF2b + drho_dp*dF0b + (drho_dp*
        u_av+rho_av*(du-dV*r1))*dF1b + (0.5*(drho_dp*q_sqr_av)+rho_av*temp4)*
        dF3b;
    q_sqr_avb = 0.5*drho_dp*tempb40;
    tempb35 = eig_a1*dF2b;
    v_avb = tempb22 + drho_dp*tempb35 + dv*tempb34 + tempb20;
    tempb21 = rho_av*tempb35;
    r2b = c_av*tempb22 - dV*tempb21 - c_av*tempb20 + (p_r+p_l)*tempb17;
    dvb = tempb21 + v_av*tempb34;
    v_lb = V_l*rho_l*tempb17 - dvb;
    v_rb = dvb + V_r*rho_r*tempb17;
    tempb36 = eig_a1*dF1b;
    u_avb = tempb25 + drho_dp*tempb36 + du*tempb34 + tempb23;
    drho_dpb = v_av*tempb35 + eig_a1*dF0b + u_av*tempb36 + 0.5*q_sqr_av*
        tempb40;
    tempb24 = rho_av*tempb36;
    r1b = c_av*tempb25 - dV*tempb24 - c_av*tempb23 + (p_r+p_l)*tempb18;
    dub = tempb24 + u_av*tempb34;
    u_lb = V_l*rho_l*tempb18 - dub;
    u_rb = dub + V_r*rho_r*tempb18;
    tempb33 = tmp*dp_m_rho_cb;
    tmpb = (dp+rho_av*c_av*dV)*dp_p_rho_cb + (dp-rho_av*c_av*dV)*dp_m_rho_cb;
    tempb31 = tmp*dp_p_rho_cb;
    rho_avb = (dv-dV*r2)*tempb35 - dV*c_av*tempb33 + dV*c_av*tempb31 + (du-dV*
        r1)*tempb36 + temp4*tempb40;
    dVb = rho_av*c_av*tempb31 - rho_av*c_av*tempb33 - r2*tempb21 - r1*tempb24 
        - V*tempb34;
    V_lb = rho_l*v_l*tempb17 + rho_l*tempb19 - dVb + rho_l*u_l*tempb18 + (e_l+
        p_l)*tempb16;
    V_rb = rho_r*v_r*tempb17 + rho_r*tempb19 + dVb + rho_r*u_r*tempb18 + (e_r+
        p_r)*tempb16;
    temp3 = 2.0*(c_av*c_av);
    tempb32 = -(drho_dpb/(c_av*c_av));
    c_avb = V*tempb30 - r2*tempb20 + r1*tempb25 + dV*rho_av*tempb31 - dp*2*
        tempb32/c_av - 2.0*2*c_av*tmpb/(temp3*temp3) - dV*rho_av*tempb33 + r2*
        tempb22 - r1*tempb23 - V*tempb27;
    dpb = tempb31 + tempb32 + tempb33;
    p_lb = r2*tempb17 - dpb + r1*tempb18 + V_l*tempb16;
    p_rb = r2*tempb17 + dpb + r1*tempb18 + V_r*tempb16;
    drhob = drho_dpb;
    rho_lb = V_l*u_l*tempb18 - drhob + V_l*tempb19 + V_l*v_l*tempb17;
    rho_rb = V_r*u_r*tempb18 + drhob + V_r*tempb19 + V_r*v_r*tempb17;
    popcontrol1b(&branch);
    if (branch == 0) {
        popreal8(&eig_a3);
        tempb13 = eig_a3b/(4.0*(eig_r3-eig_l3)+1e-6);
        tempb14 = -(eig_a3*eig_a3*4.0*tempb13/(4.0*(eig_r3-eig_l3)+1e-6));
        tempb15 = 0.25*4.0*eig_a3b;
        eig_r3b = tempb15 + tempb14;
        eig_l3b = -tempb15 - tempb14;
        eig_a3b = 2*eig_a3*tempb13;
    } else {
        eig_r3b = 0.0;
        eig_l3b = 0.0;
    }
    popcontrol1b(&branch);
    if (branch == 0) {
        eig_r2b = 0.0;
        eig_l2b = 0.0;
    } else {
        popreal8(&eig_a2);
        tempb10 = eig_a2b/(4.0*(eig_r2-eig_l2)+1e-6);
        tempb11 = -(eig_a2*eig_a2*4.0*tempb10/(4.0*(eig_r2-eig_l2)+1e-6));
        tempb12 = 0.25*4.0*eig_a2b;
        eig_r2b = tempb12 + tempb11;
        eig_l2b = -tempb12 - tempb11;
        eig_a2b = 2*eig_a2*tempb10;
    }
    popcontrol1b(&branch);
    if (branch == 0) {
        eig_r1b = 0.0;
        eig_l1b = 0.0;
    } else {
        popreal8(&eig_a1);
        tempb7 = eig_a1b/(4.0*(eig_r1-eig_l1)+1e-6);
        tempb8 = -(eig_a1*eig_a1*4.0*tempb7/(4.0*(eig_r1-eig_l1)+1e-6));
        tempb9 = 0.25*4.0*eig_a1b;
        eig_r1b = tempb9 + tempb8;
        eig_l1b = -tempb9 - tempb8;
        eig_a1b = 2*eig_a1*tempb7;
    }
    popcontrol1b(&branch);
    if (branch != 0)
        eig_a3b = -eig_a3b;
    popcontrol1b(&branch);
    if (branch != 0)
        eig_a2b = -eig_a2b;
    popcontrol1b(&branch);
    if (branch != 0)
        eig_a1b = -eig_a1b;
    if (rho_l*rho_r == 0.0)
        tempb6 = 0.0;
    else
        tempb6 = rho_avb/(2.0*sqrt(rho_l*rho_r));
    V_rb = V_rb + eig_r2b + eig_r1b + eig_r3b;
    c_rb = eig_r2b - eig_r3b;
    V_lb = V_lb + eig_l2b + eig_l1b + eig_l3b;
    c_lb = eig_l2b - eig_l3b;
    Vb = Vb + eig_a2b + eig_a1b + eig_a3b;
    c_avb = c_avb + eig_a2b - eig_a3b;
    r1b = r1b + u_r*V_rb + u_l*V_lb + u_av*Vb;
    r2b = r2b + v_r*V_rb + v_l*V_lb + v_av*Vb;
    for (ii1 = 0; ii1 < 2; ++ii1)
        Sb[ii1] = 0.0;
    Sb[1] = Sb[1] + imag*r2b;
    imagb = S[0]*r1b + S[1]*r2b;
    Sb[0] = Sb[0] + imag*r1b;
    magb = magb - imagb/(mag*mag);
    if (S[0]*S[0] + S[1]*S[1] == 0.0)
        tempb1 = 0.0;
    else
        tempb1 = magb/(2.0*sqrt(S[0]*S[0]+S[1]*S[1]));
    Sb[0] = Sb[0] + 2*S[0]*tempb1;
    Sb[1] = Sb[1] + 2*S[1]*tempb1;
    if (0.4*(h_av-0.5*q_sqr_av) == 0.0)
        tempb2 = 0.0;
    else
        tempb2 = 0.4*c_avb/(2.0*sqrt(0.4*(h_av-0.5*q_sqr_av)));
    h_avb = h_avb + tempb2;
    q_sqr_avb = q_sqr_avb - 0.5*tempb2;
    u_avb = u_avb + 2*u_av*q_sqr_avb + r1*Vb;
    v_avb = v_avb + 2*v_av*q_sqr_avb + r2*Vb;
    if (1.4*(p_r*inv_rho_r) == 0.0)
        tempb3 = 0.0;
    else
        tempb3 = 1.4*c_rb/(2.0*sqrt(1.4*(p_r*inv_rho_r)));
    if (1.4*(p_l*inv_rho_l) == 0.0)
        tempb4 = 0.0;
    else
        tempb4 = 1.4*c_lb/(2.0*sqrt(1.4*(p_l*inv_rho_l)));
    h_lb = roe_wt_1*h_avb;
    p_lb = p_lb + inv_rho_l*h_lb + inv_rho_l*tempb4;
    roe_wt_2b = v_r*v_avb + u_r*u_avb + h_r*h_avb;
    roe_wt_1b = v_l*v_avb - roe_wt_2b + u_l*u_avb + h_l*h_avb;
    h_rb = roe_wt_2*h_avb;
    p_rb = p_rb + inv_rho_r*h_rb + inv_rho_r*tempb3;
    e_rb = e_rb + 0.4*p_rb + inv_rho_r*h_rb;
    e_lb = e_lb + 0.4*p_lb + inv_rho_l*h_lb;
    tempb = -(0.4*0.5*p_rb);
    u_rb = u_rb + rho_r*2*u_r*tempb + roe_wt_2*u_avb + r1*V_rb;
    v_rb = v_rb + rho_r*2*v_r*tempb + roe_wt_2*v_avb + r2*V_rb;
    inv_rho_rb = (e_r+p_r)*h_rb + q_r[1]*u_rb + q_r[2]*v_rb + p_r*tempb3;
    tempb0 = -(0.4*0.5*p_lb);
    u_lb = u_lb + rho_l*2*u_l*tempb0 + roe_wt_1*u_avb + r1*V_lb;
    v_lb = v_lb + rho_l*2*v_l*tempb0 + roe_wt_1*v_avb + r2*V_lb;
    inv_rho_lb = (e_l+p_l)*h_lb + q_l[1]*u_lb + q_l[2]*v_lb + p_l*tempb4;
    rho_lb = rho_lb + (u_l*u_l+v_l*v_l)*tempb0;
    q_rb[3] = q_rb[3] + e_rb;
    q_lb[3] = q_lb[3] + e_lb;
    q_rb[2] = q_rb[2] + inv_rho_r*v_rb;
    q_lb[2] = q_lb[2] + inv_rho_l*v_lb;
    q_rb[1] = q_rb[1] + inv_rho_r*u_rb;
    q_lb[1] = q_lb[1] + inv_rho_l*u_lb;
    temp2 = sqrt(rho_r);
    temp1 = sqrt(rho_l);
    temp = temp1 + temp2;
    temp0 = sqrt(rho_l);
    tempb5 = -(temp0*roe_wt_1b/(temp*temp));
    if (rho_r == 0.0)
        rho_rb = rho_rb + rho_l*tempb6 - inv_rho_rb/(rho_r*rho_r) + (u_r*u_r+
            v_r*v_r)*tempb;
    else
        rho_rb = rho_rb + tempb5/(2.0*temp2) + rho_l*tempb6 - inv_rho_rb/(
            rho_r*rho_r) + (u_r*u_r+v_r*v_r)*tempb;
    if (!(rho_l==0.0))
        rho_lb = rho_lb + tempb5/(2.0*temp1) + roe_wt_1b/(temp*2.0*temp0);
    rho_lb = rho_lb + rho_r*tempb6 - inv_rho_lb/(rho_l*rho_l);
    q_rb[0] = q_rb[0] + rho_rb;
    q_lb[0] = q_lb[0] + rho_lb;
    xy1b[0] = xy1b[0] + Sb[1];
    xy2b[0] = xy2b[0] - Sb[1];
    Sb[1] = 0.0;
    xy2b[1] = xy2b[1] + Sb[0];
    xy1b[1] = xy1b[1] - Sb[0];
}
