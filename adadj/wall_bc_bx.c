/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
*/
#include <adBuffer.h>
#include "../include/structures.h"

/*
  Differentiation of wall_bc in reverse (adjoint) mode:
   gradient     of useful results: *q[0:4-1] xy1[0:2-1] xy2[0:2-1]
   with respect to varying inputs: *q[0:4-1] xy1[0:2-1] xy2[0:2-1]
   RW status of diff variables: *q[0:4-1]:in-out xy1[0:2-1]:incr
                xy2[0:2-1]:incr
   Plus diff mem management of: q:in *q:in xy1:in xy2:in
*/
void wall_bc_bx(double (*q)[4], double (*qb)[4], Dim *dim, double xy1[2], 
        double xy1b[2], double xy2[2], double xy2b[2], int j, int k) {
    int idx, widx, midx;
    int jstride = dim->jstride;
    int kstride = dim->kstride;
    int pad;
    double Sx, Sy, imag, mag;
    double Sxb, Syb, imagb, magb;
    double tmp;
    double tmp0;
    double tmp1;
    double tmp2;
    double tmpb;
    double tempb;
    double tmpb0;
    double tmpb1;
    double tmpb2;
    double tempb0;
    double tempb1;
    double tempb2;
    Sx = -xy2[1] + xy1[1];
    Sy = xy2[0] - xy1[0];
    double u, v, irho, v_dot_wall, p;
    double ub, vb, irhob, v_dot_wallb, pb;
    idx = j*dim->jstride + k*dim->kstride;
    midx = j*jstride + (2*dim->nghost-k-1)*kstride;
    // normalize wall vector
    mag = sqrt(Sx*Sx + Sy*Sy);
    imag = 1.0/mag;
    pushreal8(Sx);
    Sx = Sx*imag;
    pushreal8(Sy);
    Sy = Sy*imag;
    irho = 1.0/q[midx][0];
    // find velocity on other side of wall
    u = q[midx][1]*irho;
    v = q[midx][2]*irho;
    // reflect normal component
    v_dot_wall = Sx*u + Sy*v;
    pushreal8(u);
    u = u - 2.0*Sx*v_dot_wall;
    pushreal8(v);
    v = v - 2.0*Sy*v_dot_wall;
    tmp = q[midx][0];
    pushreal8(q[idx][0]);
    q[idx][0] = tmp;
    tmp0 = u*q[midx][0];
    pushreal8(q[idx][1]);
    q[idx][1] = tmp0;
    tmp1 = v*q[midx][0];
    pushreal8(q[idx][2]);
    q[idx][2] = tmp1;
    tmpb = qb[idx][3];
    qb[idx][3] = 0.0;
    tempb = 0.5*q[midx][0]*tmpb;
    pb = tmpb/0.4;
    qb[midx][0] = qb[midx][0] + 0.5*(u*u+v*v)*tmpb;
    popreal8(&q[idx][2]);
    tmpb1 = qb[idx][2];
    vb = q[midx][0]*tmpb1 + 2*v*tempb;
    qb[idx][2] = 0.0;
    qb[midx][0] = qb[midx][0] + v*tmpb1;
    popreal8(&q[idx][1]);
    tmpb0 = qb[idx][1];
    ub = q[midx][0]*tmpb0 + 2*u*tempb;
    qb[idx][1] = 0.0;
    qb[midx][0] = qb[midx][0] + u*tmpb0;
    popreal8(&q[idx][0]);
    tmpb2 = qb[idx][0];
    qb[idx][0] = 0.0;
    qb[midx][0] = qb[midx][0] + tmpb2;
    popreal8(&v);
    v_dot_wallb = -(2.0*Sx*ub) - 2.0*Sy*vb;
    Syb = v*v_dot_wallb - 2.0*v_dot_wall*vb;
    popreal8(&u);
    Sxb = u*v_dot_wallb - 2.0*v_dot_wall*ub;
    tempb1 = -(0.4*0.5*pb);
    tempb0 = q[midx][0]*tempb1;
    ub = ub + 2*u*tempb0 + Sx*v_dot_wallb;
    vb = vb + 2*v*tempb0 + Sy*v_dot_wallb;
    qb[midx][3] = qb[midx][3] + 0.4*pb;
    qb[midx][0] = qb[midx][0] + (u*u+v*v)*tempb1;
    qb[midx][2] = qb[midx][2] + irho*vb;
    irhob = q[midx][1]*ub + q[midx][2]*vb;
    qb[midx][1] = qb[midx][1] + irho*ub;
    qb[midx][0] = qb[midx][0] - irhob/(q[midx][0]*q[midx][0]);
    popreal8(&Sy);
    popreal8(&Sx);
    imagb = Sx*Sxb + Sy*Syb;
    magb = -(imagb/(mag*mag));
    if (Sx*Sx + Sy*Sy == 0.0)
        tempb2 = 0.0;
    else
        tempb2 = magb/(2.0*sqrt(Sx*Sx+Sy*Sy));
    Syb = 2*Sy*tempb2 + imag*Syb;
    Sxb = 2*Sx*tempb2 + imag*Sxb;
    xy2b[0] = xy2b[0] + Syb;
    xy1b[0] = xy1b[0] - Syb;
    xy1b[1] = xy1b[1] + Sxb;
    xy2b[1] = xy2b[1] - Sxb;
}
