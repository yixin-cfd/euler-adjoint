/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
*/
#include <adBuffer.h>
#include "../include/structures.h"

/*
  Differentiation of wall_bc in reverse (adjoint) mode:
   gradient     of useful results: *q[0:4-1] xy1[0:2-1] xy2[0:2-1]
   with respect to varying inputs: *q[0:4-1] xy1[0:2-1] xy2[0:2-1]
   RW status of diff variables: *q[0:4-1]:in-out xy1[0:2-1]:incr
                xy2[0:2-1]:incr
   Plus diff mem management of: q:in *q:in xy1:in xy2:in
*/
void wall_bc_bx(double (*q)[4], double (*qb)[4], double (*rhs)[4], Dim *dim, 
        double xy1[2], double xy1b[2], double xy2[2], double xy2b[2], int j, 
        int k) {
    int idx, widx, midx;
    int jstride = dim->jstride;
    int kstride = dim->kstride;
    int pad;
    double Sx, Sy, imag, mag;
    double Sxb, Syb, imagb, magb;
    double tmp;
    double tmp0;
    double tmp1;
    double tmp2;
    double tmpb;
    double tmpb0;
    double tempb;
    double tmpb1;
    double tempb0;
    double tmpb2;
    double tempb1;
    Sx = -xy2[1] + xy1[1];
    Sy = xy2[0] - xy1[0];
    double u, v, irho, v_dot_wall, p;
    idx = j*dim->jstride + k*dim->kstride;
    midx = j*jstride + (2*dim->nghost-k-1)*kstride;
    // normalize wall vector
    mag = sqrt(Sx*Sx + Sy*Sy);
    imag = 1.0/mag;
    pushreal8(Sx);
    Sx = Sx*imag;
    pushreal8(Sy);
    Sy = Sy*imag;
    // irho = 1.0 / q[midx][0];
    // // find velocity on other side of wall
    // u = q[midx][1]*irho;
    // v = q[midx][2]*irho;
    // p = (GAMMA - 1.0)*(q[midx][3] - 0.5*q[midx][0]*(u*u + v*v));
    // reflect normal component
    // v_dot_wall = Sx * u + Sy * v;
    // u = u - 2.0*Sx*v_dot_wall;
    // v = v - 2.0*Sy*v_dot_wall;
    // q[idx][0] = q[midx][0];
    // q[idx][1] = u*q[midx][0];
    // q[idx][2] = v*q[midx][0];
    // q[idx][3] = p / (GAMMA - 1.0) + 0.5*q[midx][0]*(u*u + v*v);
    // q[idx][1] = q[midx][0]*(u - 2.0*Sx*Sx*u + -2.0*Sx*Sy*v);
    // q[idx][2] = q[midx][0]*(v - 2.0*Sy*Sx*u + -2.0*Sy*Sy*v);
    tmp = q[midx][0];
    q[idx][0] = tmp;
    tmp0 = q[midx][1] - 2.0*Sx*Sx*q[midx][1] - 2.0*Sx*Sy*q[midx][2];
    pushreal8(q[idx][1]);
    q[idx][1] = tmp0;
    // rhs[idx][0] =  rhs[midx][0];
    // rhs[idx][1] = -rhs[midx][1];
    // rhs[idx][2] = -rhs[midx][2];
    // rhs[idx][3] =  rhs[midx][3];  
    tmpb = qb[idx][3];
    qb[idx][3] = 0.0;
    qb[midx][3] = qb[midx][3] + tmpb;
    tmpb0 = qb[idx][2];
    qb[idx][2] = 0.0;
    tempb = -(2.0*q[midx][1]*tmpb0);
    qb[midx][2] = qb[midx][2] + (1.0-2.0*(Sy*Sy))*tmpb0;
    Syb = Sx*tempb - q[midx][2]*2.0*2*Sy*tmpb0;
    qb[midx][1] = qb[midx][1] - 2.0*Sx*Sy*tmpb0;
    popreal8(&q[idx][1]);
    tmpb1 = qb[idx][1];
    qb[idx][1] = 0.0;
    tempb0 = -(2.0*q[midx][2]*tmpb1);
    Sxb = Sy*tempb0 - q[midx][1]*2.0*2*Sx*tmpb1 + Sy*tempb;
    qb[midx][1] = qb[midx][1] + (1.0-2.0*(Sx*Sx))*tmpb1;
    Syb = Syb + Sx*tempb0;
    qb[midx][2] = qb[midx][2] - 2.0*Sx*Sy*tmpb1;
    tmpb2 = qb[idx][0];
    qb[idx][0] = 0.0;
    qb[midx][0] = qb[midx][0] + tmpb2;
    popreal8(&Sy);
    popreal8(&Sx);
    imagb = Sx*Sxb + Sy*Syb;
    magb = -(imagb/(mag*mag));
    if (Sx*Sx + Sy*Sy == 0.0)
        tempb1 = 0.0;
    else
        tempb1 = magb/(2.0*sqrt(Sx*Sx+Sy*Sy));
    Syb = 2*Sy*tempb1 + imag*Syb;
    Sxb = 2*Sx*tempb1 + imag*Sxb;
    xy2b[0] = xy2b[0] + Syb;
    xy1b[0] = xy1b[0] - Syb;
    xy1b[1] = xy1b[1] + Sxb;
    xy2b[1] = xy2b[1] - Sxb;
}
